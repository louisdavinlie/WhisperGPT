content,tokens
"Minute 0: I would like you to design a reservation and payment system for a parking garage. Welcome everyone to another mock interview at Exponent. Today we're going to be doing a systems design interview question with Tim. Before we dive in, Tim would you like to introduce yourself? Yeah for sure. So hey my name is Tim. I'm a software engineer. I've been doing engineering for a couple years now. Previously worked at some large tech companies like Amazon Lab 126 or Airbnb. Currently working on some startup stuff on my own. Nice. Thanks for being with us today Tim. So the question today, I would like you to design a reservation and payment system for a parking garage. All right awesome. Yeah we can just dive right into it if you'd like. The first thing I like to do generally is sort of clarify the requirements a little bit. Just make sure I'm not making any like incorrect assumptions. So the startup",191
"Minute 1: I guess I'll write some of them down just to make sure I've got them off the bat. Sure. Let's see. So for this type of reservation system, presumably we need a way to be able to like reserve a parking spot and maybe receive some kind of I guess ticket or receipt? Yes, that's correct. You obviously need to be able to pay for the parking spot. Yep. And then I guess this might be more of like a scale requirement but at a higher level if we think about this type of like product we'd probably prefer to err on the side of higher consistency. Yeah. Because like if I'm thinking about it we probably don't want two people to be able to reserve the same parking spot obviously. Yep, absolutely. Cool. And then I'm curious are there different types of parking because if I think about like a normal parking lot...",182
"Minute 2: garage, you know, there's like, there's various, there's like maybe a handicap spot, maybe some larger spots, maybe some smaller spots. So I think for this question, let's restrict it to three types of spots, depending on the size of the vehicle. So compact, regular, and large vehicles. Large. Awesome. And then for the, are the prices for the garages, would they be flat rate? Yeah, let's say flat rate, but different rates for the three different types of parking. And flat rate based on time. Cool. All right, awesome. Yeah, no, that makes a lot of sense to me. And then obviously, I believe this should be some form of, I guess, web app or mobile app interfacing with a backend server. So with these, I guess, product requirements in mind, I guess we can dive right into the defining the sort of interface or the API we're going to be working with.",203
"Minute 3: working with. So I think this type of thing is going to have some public endpoints and then some internal endpoints. So I'll maybe start us off with some of the more public endpoints. So off the bat, we need, as we mentioned in the product requirements, a way to reserve. So let's call this one slash reserve. And I'm just calling it this. In reality, it doesn't have to be like immediately RESTful. It could be like GraphQL or anything. This is just so we have a general understanding of what this should look like. I think that sounds good. And so what should this type of thing take? We obviously want to know which garage we're referring to. We want to know, I guess, when the time duration during which this should be reserved as well. So that seems pretty reasonable. So let's go with those. Something along those lines. And then, as we mentioned in sort of product requirements, we should return some type of receipt or ticket. So let's say I return.",218
"Minute 4: turns a tuple. Obviously we want the specific spot as well as potentially like a way to identify which specific reservation we're referring to. So we just call that like a reservation ID. So yeah, that seems reasonable for that. Then there's obviously, there should be some form of payment endpoint. And obviously this is probably beyond the scope of the specific problem per se, but the actual implementation could probably just be handled by like a third party. So yeah, we wanna pay by reservation ID. And then I wanna say like, you can probably end up using something like Stripe or Square or like alternatively, you can implement your own. That's like a little more complex. Yeah, I think we can assume that a third party will be taking care of that. Cool. Yeah. Awesome. And then, yeah, you also, oh, you gotta be able to cancel your...",183
"Minute 5: your reservation, that seems pretty reasonable. Just because, you know, things come up in general. So you should have a cancel endpoint as well. Let's call that here, text left. And yeah, similarly, you should be able to just be able to pass the reservation ID. And I think it should handle the rest on its own. So that seems pretty reasonable for I think our public endpoints, at least for the functionality that we're describing here. We're probably gonna have a few more endpoints in the internal end. So let's get started on those. And so taking a look at the public endpoints that we've sort of created here, there's like a few internal things we might need. One thing we need is a way to calculate the actual individual payments on the internal side. And debatably that could just be part of the initial endpoint, but personally I prefer.",187
"Minute 6: to separate them out. So let's see here. And yeah, so similarly, that should just take the reservation ID, because presumably, and we can delve into this more later when we define our actual data schema, but presumably the reservation ID tells us which specific garage we're referring to and then what the actual times are. That way, we can get the individual rates based on what garage it is and what time. So that should be fine. And then on the reserve side, we probably need a, let's say a way to check what spots are currently available. That seems pretty reasonable from a UI perspective. So let's say we have a free spots endpoints. And one thing, I guess, when we're considering the parameters of what this specific endpoint might require, obviously we need this, the garage. But one other thing that.",176
"Minute 7: Some other things that might be prudent are like the type of vehicle or the time. And the reason I say that is if we think about it, the larger spots, like you mentioned that over here we say we define like there's a compact, there's a regular, and there's a large. The larger spots actually end up being able to be used for the smaller vehicles. Obviously we would prefer to not have to do that down the line. Like we would prefer to use up all the smaller spots. But reasonably if all of those spots are full and someone wants to reserve a spot, they should be able to reserve a larger spot, at least in my opinion. So those are just some things to note, I guess. And then there's some of the more complex logic that's going to be held should be in the actual allocation of the spot. We don't have to dive into the minutia of the actual algorithm of that right now. But for now, let's just define that as, let's say, allocate spot. And that should simplify.",221
"Minute 8: similarly take a garage ID, a vehicle type, and a time. Okay. Cool. And, yeah, that seems pretty reasonable for the three we have here. Some of the more optional things I guess we could be adding, if I'm thinking more about the actual product. Obviously, the ability to create an account seems pretty reasonable. If it's like a garage you're going to be using over and over, we may want to incorporate that. So, let's say we have a create an account endpoint. Some things that we might need there are, let's say, an email and a password seem pretty reasonable for the initial things. And obviously, we do some hashing for that. We don't want to store that in plain text. Then some more optional things, like let's say first name or last name. Yeah. I mean, just as another thing to note, optionally, you could also just implement third party like single sign-on options like Google or Facebook login. Yeah.",206
"Minute 9: And their payment details, I'm assuming, are going to be taken care of by whatever third party's handling that. Exactly. Yeah. Cool. And then let's say we just have like a login endpoint, just because you need that once you've created an account. Cool. So I think that seems pretty reasonable, at least on the first pass for the specific system interface we're working with. So let's maybe consider the actual scale or scope of the problem. And we tackled that briefly when we discussed how we want high consistency, given the nature of this problem. But let's look at the actual size or far-reaching extent. It's honestly my initial impression is that we're not likely to deal with many at-scale issues with this type of problem. On a per-garage basis, even if we upper bound a garage.",176
"Minute 10: garage optimistically at like 10 floors. Like I don't think the average parking garage is going to have 10 floors, but let's upper bound it just for the sake of this problem. And let's say it has maybe like 200 spots per floor. That's like 2000 relevant spots per garage. And the system, like, I guess what 2000 relevant spots per garage. I don't think there's that many parking garages in the world. Um, so I'm not particularly concerned about designing this as a more distributed system, like I think even if there's like a million parking garages, I don't like, that's still not within the realm of like big data in my opinion. Um, so I don't think that really factors into the considerations here. Um, that being said, as we mentioned before, we care most about the system being up to date. Uh, we don't really want to run into a race condition where like we happen to allocate to the same spots at the same time. Um, so those are just something to keep in mind. Um, and then, yeah, I guess, given that we are not probably not going to run that into that many at scale issues, um, we can sort of jump over to the data schema side of things, how we're going to design the database. Sounds good.",278
"Minute 11: So, let me shift over here on Whimsical. Yep. Data schema. Cool. So, I guess what are some of the first things we probably want to tackle here? Reservations are obviously the point of this entire product. So, we can start with that. Let's go with reservations. Create a table here. Cool. And to start us off, we have, I guess as most tables will, we have an ID. And this is our primary key. We can sort of define it as a serial within most relational databases. And I apologize. I tend to lean towards relational databases for most of this type of problem. Reasonably speaking, you could probably go into more of a NoSQL type solution. But just more of my expertise.",158
"Minute 12: lies in the relational database side. So presumably, some type of Postgres or MySQL is what we'll be working with here in this type of thing. So I'll be designing the data schema with that sort of perspective in mind. OK, that's totally fine. Awesome. So yeah, back to the reservations, initial field, ID, the serial. That way, it sort of increments as you add more and more. It seems totally reasonable. What else would we want? So the other information we'd want in this sort of table, we need which specific garage it's referring to, which spot we actually ended up allocating to it. And then the start and end time seem like pretty reasonable things. As well as, oh, also whether or not, I guess this has been paid. Depending on how you want to format the product, you might be able to pay on site as opposed to in the app, per se. So that sort of status might be reasonable. Yeah, I think that's good. Garage ID, and I think we can, presumably, we're going to be making a table.",231
"Minute 13: down the line with this. We'll call this foreign key as well. Then let's see. We have the spot ID. Now that I think about it, it's probably not unreasonable to make a spot table as well. That way it could sort of have the potential vehicle types and whether or not it's reserved at a specific time. So let's go with that also. And then we want the start time. We want the end time. And yeah, I guess it's just paid or not paid. So we can just call that paid. Cool. So yeah, that seems pretty reasonable for a reservation table. And obviously we can end up adding like user ID or such if we end up having those. But like for now, this is like the important part. Yeah, I think this is good to start with. Yeah, so let's, I guess, move over to creating a garage table or garage table. There's this whole debate over whether or not you should be using singular or plural.",209
"Minute 14: or plural in table names. Honestly, I'm probably in the singular camp, even though I just wrote reservations. But I don't think it matters either way for the sake of this problem. That's fine, yeah. Yeah, so this will also obviously have an ID. Similarly, key and serial. So what are some of the things we want for the garage? Where it is, I guess, something that's generally pretty important. And that can also help down the line when it comes to actually sharding specific replicas of the database, or load balancing, things like that. Just an easy way off the bat to handle that is zip code. That's pretty universal. So let's go with that. And to be able to incorporate, I guess, the extensions of zip codes, that requires a hyphen. So maybe let's go with VARCHAR instead of an int. And then what else do we want? We want the individual rates. We mentioned that this is a.",206
"Minute 15: flat rate based on size. So for now, yeah, it seems relatively reasonable to have a sort rate per size. And then obviously, these are like nullable columns in the case that they don't have that specific type of spot in the specific garage. And one thing to note here is I'm using decimal. I know there's obviously some issues down the line regarding like floating point errors and calculations and payments. I think decimal is the Postgres type that should be able to handle that. I'm not confident that there's an equivalent MySQL type, but I'm sure there is. So I think that seems like a pretty reasonable approach. I think that's fine. And then let's go with spots. Like we mentioned, we have a spot table that is here. Similar to the other ones, we want ID with a primary key, serial, and what do we want?",183
"Minute 16: the spot. We want the relevant garage, obviously. We want the type of vehicle. And then we want, I guess, the specific status. Like, what is it like? Maybe it's being reserved. Maybe it's like unavailable right now. Like, maybe they're like, I don't know, paving over the spot. Or maybe it's just totally empty. So I think those are pretty reasonable things to have there. Okay. So the garage ID, obviously, it's a foreign key. And I guess it's a secondary key. And then we want the vehicle type. And for now, I'm going to call this an enum. And I'll get into this a little later when we actually define, well, actually, I can get into this now, I guess. There's sort of like a tradeoff there when you end up adding enums, particularly in like a relational database. Just simply because you become more performant because you have all the benefits.",204
"Minute 17: sort of being an int as opposed to like a, you know, like a character string or whatever. But the trade-off there is there's some like flexibility issues down the line. I know in Postgres specifically when you add an enum you can never remove it, like you can never remove the type afterwards. So that's like something to consider when you end up choosing an enum. I think for this specific case, like compact, regular, and large, I don't think those are things that are like ever going to be like totally out of phase in a parking garage type system. So I think it's totally reasonable to add an enum here. But like I mentioned before, I don't think we're going to run into issues at scale here. It would be totally reasonable to be like just a vericare as well for like flexibility and then sort of have that vetting on the application layer side. Yeah, I think that's fine. You can make a call over here on the trade-off that you're willing to go for. For sure. Cool. And then what else? Oh, we had the, I guess, supposedly the optional table, given that we optionally want to be able to create an account. So let's say we have a user's Loss Okay.",266
"Minute 18: table and that should just add all the familiar things. We have the ID with the primary key, it's a serial. And then as we mentioned in the previous endpoints that were optional, maybe an email or I guess, fair care, because we're in Postgres. And then, okay as well. And note that this is probably like something conventional, let's say like a SHA-256 hash, something like that. Okay. And then, yeah, first name, obviously nullable as well, and last name, cool. And then, I guess arguably, if I'm thinking about like the nature of this type of application, the whole reason we wanted an optional users in the first place is just so they could like recurringly reserve a spot. And if we wanna be able to recurringly reserve a spot, we probably also want the type of vehicle. Actually, we might want the type of vehicle in general.",192
"Minute 19: a vehicle table is like a totally reasonable thing to have in this sort of scenario. Yep, I think that's fine. And then let's go with ID as usual. And then, yeah, so optionally like a user ID, that can be a foreign key and int. And then let's say we want their license, seems reasonable. And then, yeah, probably the vehicle type, again, similar to the one that was in the spots table. So yeah, I think that probably covers our requirements here. I mean, obviously I can add more as we go through the problem, but for now, does that seem like a? I think this seems good. Yeah, this looks reasonable. Maybe we can dive into what the high level architecture would look like. Yeah, for sure.",164
"Minute 20: So yeah, we can sort of get into that here. We start us off with the very basics. We want a application UI. It can be either web or mobile. And then we want some sort of backend server. So let's say here we have a web app or mobile UI, depending on the sort of need, or maybe even both. And then yeah, over here, let's go with a sort of a backend server. Yeah, this will talk to this, vice versa. Cool. Now, some of the more, the deeper considerations to have, I guess, here are obviously we're going to have a database. As we mentioned before, the one that I end up leaning towards is sort of like a Postgres DB. So let's just call this DB, and then go here.",168
"Minute 21: here. And so that's just like off the bat. In reality, we can end up doing a number of different adjustments here, I guess. One thing that we can consider is that a potential consideration is splitting the backend server into like a reservation server and a slot server, given the complexity of like allocating slots. That seems probably a little unnecessary here. A bigger thing that might be more reasonable is given that we sort of described up here that the system needs to have a high consistency, we noticed that in this type of problem, we probably want to be able to read more, like way more than write. So if we're going to be reading a lot more than writing, we probably want a number of different read replicas for the DB. So we can actually, let's say separate out this here.",170
"Minute 22: up this way and then can I just copy this? Oh, yes I can. Awesome. So yeah, let's call this a read replica. I'm going to read replica. So yeah, the server would kind of work like this. It would essentially go here and one thing to have or that would be prudent to have in this sort of scenario. Given that we're probably hosting like a number of read replicas, we probably want some form of load balancer in between just to sort of allocate where the individual calls are going. It would probably be prudent for this type of problem to shard that based on location. I know that we mentioned earlier like the garage might have like a zip code. That seems like a pretty reasonable way to approach that. Yeah. Let's add this here.",166
"Minute 23: From here we can go up here, call this read. Call this read. This one will be right. Yeah, and then what else? Oh, we mentioned, oh, go for it. I was gonna ask, do you anticipate any trade-offs based on this decision? Yeah, well, not specifically the read replica portion. One thing that I guess is likely going to end up being a specific trade-off, as I was sort of pathing towards, we mentioned that this type of thing sort of wants a high consistency. So I think it's pretty reasonable to take a strong consistency approach versus an eventual consistency approach, just simply because if we think about the nature of someone using this application, including online hawking, I guess, the route that everyone takes",160
"Minute 24: from a customer perspective, it's likely not the case that they're going to be super frequently reserving things, like probably not more than like even twice a day at most. And that already seems a little excessive. So in reality, they're probably very willing to wait or deal with like a higher latency, which is I guess the trade-off you make when you have a strong consistency versus like eventual consistency where you like increase the performance, or I guess the execution on the customer side, like in the customer's view, but the trade-off you make there is like, you might not have the exact data. We want exact data because we want them to be able to know that the spot that they're reserving is like specifically the spot that they'll get. And the way that that's tackled in this sort of setup is you basically read lock. That's like an initial approach that a lot of people use. Seems pretty reasonable as well, especially for something that's not necessarily at an aggressive scale. I mean, the sense that when someone's writing.",221
"Minute 25: to the Postgres DB, you read lock the replicas. That way they sort of wait for the result to finish. That way you know the data is as up to date as possible. One potential consideration in the future of that might be, depending on how you want to split up and shard your database, you might want to consider the logic of read locking based on location. Because if we think about it, why would we read lock, I don't know, something in Wisconsin if someone's reserving something in California. But that's a little more of a complex decision down the line. OK. Yeah, I think that would be a good next step. Cool. And then, yeah, I think that's one other thing. We mentioned up here that we have a payment, and it's likely to be using an existing third party payment. So yeah, we just draw that in here. Let's say it's like a.",196
"Minute 26: So place that here. I've got here both ways. Don't really know how to do this. Oh, there we go. Cool. Nice. Okay. I think this is pretty good and a good place to stop. What did you think about that, Tim? It's sort of an interesting, weird problem, I guess. I think a lot of these types of problems end up actually having issues at scale. So I think I was lucky in the sense that I think it's reasonable to say with some like back of the envelope for me estimation that this sort of problem doesn't tackle that. And that made it a lot more of, I guess, how do we design the data problem? Got it. Yeah. Now, I think some things that you did really well. So clarification questions at the beginning were very, they were well drawn out by you. And that made the scope of the question a lot more.",192
"Minute 27: a lot more manageable as well for you to tackle and to just understand exactly what the requirements were. And I think one thing that I saw you do consistently and that was really good was providing your opinions. So explaining what the problem was, why you were doing something, what your opinion on it was. Like one example was just separating the payment calculation from the public endpoint. That was a small example where you suggested that you were gonna separate it and you provided a reason for that. And I think that you did that consistently throughout, which just shows that you would be someone who people would enjoy working with as an engineer because you have opinions on things. And it's conversational too. It adds flavor to the question that you're doing. It doesn't sound very robotic and rehearsed and just adds some commentary for the interviewer to be able to interact with.",177
"Minute 28: with as well. And I like that towards the end you called out that you weren't super confident on the use of decimal as the type. Things like that I think are good for interviewees to do. Just if there is something that people aren't super confident about, call it out. It's better to just throw it out there than kind of go into it blind because then at least the interviewer knows exactly where you stand and what you might need help with or hence with at some point in the question. What advice do you think you'd give someone if they were to receive this question? Yeah, I mean I think a lot of people approach these types of problems very, sort of I guess almost too strictly formulaically. And I think that's good to an extent. I think a lot of the reason for that is like algo problems are like another metric that people are generally evaluated on and that honestly probably doesn't have too much bearance on the actual job.",201
